## Day54: 动态规划part11

### 123.买卖股票的最佳时机III

[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)  [文章讲解](https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html)  [视频讲解](https://www.bilibili.com/video/BV1WG411K7AR/)

#### 题目描述：

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

> 输入：prices = [3,3,5,0,0,3,1,4]
> 输出：6
> 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
>      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

**示例 2：**

> 输入：prices = [1,2,3,4,5]
> 输出：4
> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易> 所能获得利润 = 5-1 = 4 。   
>      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
>      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

#### 参考解法：

这道题目相对[121.买卖股票的最佳时机](https://programmercarl.com/0121.买卖股票的最佳时机.html)和[122.买卖股票的最佳时机II](https://programmercarl.com/0122.买卖股票的最佳时机II.html)难了不少。关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。

**动态规划五部曲**：

1. **确定dp数组以及下标的含义**

一天一共就有五个状态，

1.没有操作 （其实我们也可以不设置这个状态，使用0代替）

2.第一次持有股票

3.第一次不持有股票

4.第二次持有股票

5.第二次不持有股票

`dp[i][j]`中`i`表示第`i`天，`j`为 [0 - 4] 五个状态，`dp[i][j]`表示第`i`天状态`j`所剩最大现金。

需要注意：`dp[i][1]`，**表示的是第`i`天，买入股票的状态，并不是说一定要第`i`天买入股票**。例如`dp[i][1]` ，并不是说第`i`天一定买入股票，有可能第`i-1`天 就买入了，那么 `dp[i][1]` 延续买入股票的这个状态。

2. **确定递推公式**

达到`dp[i][1]`状态，有两个具体操作：

- 操作一：第`i`天买入股票了，那么`dp[i][1] = dp[i-1][0] - prices[i]`
- 操作二：第`i`天没有操作，而是沿用前一天买入的状态，即：`dp[i][1] = dp[i - 1][1]`

两者中一定是选最大的，所以 `dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1])`;

同理`dp[i][2]`也有两个操作：

- 操作一：第`i`天卖出股票了，那么`dp[i][2] = dp[i - 1][1] + prices[i]`
- 操作二：第`i`天没有操作，沿用前一天卖出股票的状态，即：`dp[i][2] = dp[i - 1][2]`

所以`dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])`

同理可推出剩下状态部分：

`dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);`

`dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);`

3. **dp数组如何初始化**

第0天没有操作，这个最容易想到，就是0，即：`dp[0][0] = 0`;

第0天做第一次买入的操作，`dp[0][1] = -prices[0]`;

第0天做第一次卖出的操作，可以理解当天买入，当天卖出，所以`dp[0][2] = 0`;

第0天第二次买入操作，由于第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。

所以第二次买入操作，初始化为：`dp[0][3] = -prices[0]`;

同理第二次卖出初始化`dp[0][4] = 0`;

4. **确定遍历顺序**

从递归公式其实已经可以看出，一定是从前向后遍历，因为`dp[i]`，依靠`dp[i - 1]`的数值。

5. **举例推导dp数组**

以输入[1,2,3,4,5]为例

![123.买卖股票的最佳时机III](imgs/20201228181724295-20230310134201291.png)

红色框为最后两次卖出的状态。现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。即，如果第一次卖出已经是最大值了，那么可以在当天立刻买入再立刻卖出。所以`dp[4][4]`已经包含了`dp[4][2]`的情况。也就是说第二次卖出手里所剩的钱一定是最多的，所以最终最大利润是`dp[4][4]`。

```cpp
class Solution
{
 public:
	int maxProfit(vector<int>& prices)
	{
		int len = prices.size();
		// 不操作 第一次持有 第一次卖出 第二次持有 第二次卖出
		vector<vector<int>> dp(len, vector<int>(5));
		dp[0][1] -= prices[0];
		dp[0][3] -= prices[0];
		for (int i = 1; i < len; i++)
		{
			dp[i][0] = dp[i - 1][0];
			dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
			dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
			dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
			dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
		}
		return dp[len - 1][4];
	}
};
```

优化空间写法：

```cpp
// 版本二
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<int> dp(5, 0);
        dp[1] = -prices[0];
        dp[3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[1] = max(dp[1], dp[0] - prices[i]);
            dp[2] = max(dp[2], dp[1] + prices[i]);
            dp[3] = max(dp[3], dp[2] - prices[i]);
            dp[4] = max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
    }
};
```

其中，会发现dp[2]利用的是当天的dp[1]，但结果也是对的：

dp[1] = max(dp[1], dp[0] - prices[i]); 如果dp[1]取dp[1]，即保持买入股票的状态，那么 dp[2] = max(dp[2], dp[1] + prices[i]);中dp[1] + prices[i] 就是今天卖出。

如果dp[1]取dp[0] - prices[i]，今天买入股票，那么dp[2] = max(dp[2], dp[1] + prices[i]);中的dp[1] + prices[i]相当于是今天再卖出股票，一买一卖收益为0，对所得现金没有影响。相当于今天买入股票又卖出股票，等于没有操作，保持昨天卖出股票的状态了。

**这种写法看上去简单，其实思路很绕，不建议大家这么写，这么思考，很容易把自己绕进去！**

### 188.买卖股票的最佳时机IV

[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)  [文章讲解](https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html)  [视频讲解](https://www.bilibili.com/video/BV16M411U7XJ/)

#### 题目描述：

给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1：**

> 输入：k = 2, prices = [2,4,1]
> 输出：2
> 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

**示例 2：**

> 输入：k = 2, prices = [3,2,6,5,0,3]
> 输出：7
> 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
>      随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

#### 我的解法：

动规五部曲，分析如下：

1. **确定dp数组以及下标的含义**

类比[123.买卖股票的最佳时机III](https://programmercarl.com/0123.买卖股票的最佳时机III.html)，使用二维数组 `dp[i][j]` ：第`i`天的状态为`j`，所剩下的最大现金是`dp[i][j]`

`j`的状态表示为：

- 0 表示不操作
- 1 第一次买入
- 2 第一次卖出
- 3 第二次买入
- 4 第二次卖出
- .....

**除了0以外，偶数就是卖出，奇数就是买入**。

题目要求是至多有`k`笔交易，那么`j`的范围就定义为 `2 * k + 1` 就可以了。

所以二维dp数组的C++定义为：

```cpp
vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
```

2. **确定递推公式**

`dp[i][1]`，**表示的是第`i`天，买入股票的状态，并不是说一定要第i天买入股票**。

达到`dp[i][1]`状态，有两个具体操作：

- 操作一：第`i`天买入股票了，那么`dp[i][1] = dp[i - 1][0] - prices[i]`
- 操作二：第`i`天没有操作，而是沿用前一天买入的状态，即：`dp[i][1] = dp[i - 1][1]`

选最大的，所以`dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1])`;

同理`dp[i][2]`也有两个操作：

- 操作一：第`i`天卖出股票了，那么`dp[i][2] = dp[i - 1][1] + prices[i]`
- 操作二：第`i`天没有操作，沿用前一天卖出股票的状态，即：`dp[i][2] = dp[i - 1][2]`

所以`dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])`

同理可以类比剩下的状态，代码如下：

```cpp
for (int j = 0; j < 2 * k - 1; j += 2) {
    dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
    dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
}
```

**本题和[123.买卖股票的最佳时机III](https://programmercarl.com/0123.买卖股票的最佳时机III.html)最大的区别就是这里要类比`j`为奇数是买，偶数是卖的状态**。

3. **dp数组如何初始化**

第0天没有操作，这个最容易想到，就是0，即：`dp[0][0] = 0`;

第0天做第一次买入的操作，`dp[0][1] = -prices[0]`;

第0天做第一次卖出的操作，即当天买入，当天卖出，所以`dp[0][2] = 0`;

第0天第二次买入操作，由于第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。

所以第二次买入操作，初始化为：`dp[0][3] = -prices[0]`;

第二次卖出初始化`dp[0][4] = 0`;

**所以同理可以推出`dp[0][j]`当`j`为奇数的时候都初始化为 `-prices[0]`**

代码如下：

```cpp
for (int j = 1; j < 2 * k; j += 2) {
    dp[0][j] = -prices[0];
}
```

**在初始化的地方同样要类比j为偶数是卖、奇数是买的状态**。

4. **确定遍历顺序**

从递归公式其实已经可以看出，一定是从前向后遍历，因为`dp[i]`，依靠`dp[i - 1]`的数值。

5. **举例推导dp数组**

以输入[1,2,3,4,5]，k=2为例。

![188.买卖股票的最佳时机IV](imgs/20201229100358221.png)

最后一次卖出，一定是利润最大的，`dp[prices.size() - 1][2 * k]`即红色部分就是最后求解。

以上分析完毕，C++代码如下：

```cpp
class Solution
{
 public:
	int maxProfit(int k, vector<int>& prices)
	{

		if (prices.size() == 0) return 0;
		vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
		for (int j = 1; j < 2 * k; j += 2)
		{
			dp[0][j] = -prices[0];
		}
		for (int i = 1; i < prices.size(); i++)
		{
			for (int j = 0; j < 2 * k - 1; j += 2)
			{
				dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
				dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
			}
		}
		return dp[prices.size() - 1][2 * k];
	}
};
```

优化空间写法：

```cpp
// 版本二 空间优化写法
class Solution2
{
 public:
    int maxProfit(int k, vector<int>& prices)
    {
       int len = prices.size();
       vector<int> dp(2 * k + 1, 0);

       // 初始化
       for (int i = 1; i < 2 * k + 1; i++)
       {
          if (i % 2 == 1) dp[i] -= prices[0];
       }

       for (int i = 1; i < len; i++)
       {
          for (int j = 1; j < 2 * k + 1; j += 2)
          {
             dp[j] = max(dp[j], dp[j - 1] - prices[i]);
             dp[j + 1] = max(dp[j + 1], dp[j] + prices[i]);
          }
       }

       return dp[2 * k];
    }
};
```

### 今日总结

更多状态的动态规划，要学会举一反三。

## Day24: 回溯算法part01

### 回溯算法理论基础

回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。在二叉树中，已经提到过了回溯，例如 257. [二叉树的所有路径](./day17二叉树part04.md)。

题目分类大纲如下：

![回溯算法大纲](imgs/20210219192050666.png)

#### 回溯法的效率

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

那么既然回溯法并不高效为什么还要用它呢？

因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。

#### 回溯法解决的问题

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

其中，要注意**组合是不强调元素顺序的，排列是强调元素顺序**。

例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。即组合无序，排列有序，就可以了。

#### 如何理解回溯法

**回溯法解决的问题都可以抽象为树形结构**。因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

#### 回溯法模板

回溯三部曲。

- 回溯函数模板返回值以及参数

在回溯算法中，函数起名字可以为backtracking。回溯算法中函数返回值一般为void。

因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。

```cpp
void backtracking(参数)
```

- 回溯函数终止条件

既然是树形结构，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

```cpp
if (终止条件) {
    存放结果;
    return;
}
```

- 回溯搜索的遍历过程

回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

如图：

![回溯算法理论基础](imgs/20210130173631174.png)

注意图中特意举例集合大小和孩子的数量是相等的！

回溯函数遍历过程伪代码如下：

```cpp
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。

backtracking这里自己调用自己，实现递归。

从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

分析完过程，回溯算法模板框架如下：

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

### 77. 组合

[LeetCode](https://leetcode.cn/problems/combinations/)  [文章讲解](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)  [视频讲解1](https://www.bilibili.com/video/BV1ti4y1L7cv/)  [视频讲解2](https://www.bilibili.com/video/BV1wi4y157er/)

#### 题目描述：

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例 1：**

> 输入：n = 4, k = 2
> 输出：
> [
>   [2,4],
>   [3,4],
>   [2,3],
>   [1,2],
>   [1,3],
>   [1,4],
> ]

#### 思路：

直接的解法当然是使用for循环，例如示例中k为2，很容易想到 用两个for循环，这样就可以输出 和示例中一样的结果。

代码如下：

```cpp
int n = 4;
for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        cout << i << " " << j << endl;
    }
}
```

输入：n = 100, k = 3 那么就三层for循环，代码如下：

```cpp
int n = 100;
for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        for (int u = j + 1; u <= n; n++) {
            cout << i << " " << j << " " << u << endl;
        }
    }
}
```

如果n为100，k为50呢，那就50层for循环！要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题。

递归来做层叠嵌套（可以理解是开k层for循环），**每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了**。

把组合问题抽象为如下树形结构：

![77.组合](imgs/20201123195223940.png)

每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。**图中可以发现n相当于树的宽度，k相当于树的深度。图中每次搜索到了叶子节点，我们就找到了一个结果**。

#### 我的解法：

![77.组合1](imgs/20201123195242899.png)

```C++
class Solution
{
 private:
	// start --循环开始，end --循环结束，k --最大递归次数
	// path --存放一次完整的结果，result --存放所有的结果
	void backtracking(int start, int end, int k, vector<int>& path, vector<vector<int>>& result)
	{
		// 终止条件，找够了一次的结果
		if (path.size() >= k)
		{
			result.push_back(path);
			return;
		}

		for (int i = start; i <= end - (k - path.size()) + 1; ++i) // 剪枝
		// for (int i = start; i <= end; ++i) // 原始循环
		{
			path.push_back(i);
			// i + 1 中包含着回溯
			backtracking(i + 1, end, k, path, result);
			path.pop_back(); // 回溯
		}
	}

 public:
	vector<vector<int>> combine(int n, int k)
	{
		vector<int> nums;
		vector<vector<int>> result;
		backtracking(1, n, k, nums, result);
		return result;
	}
};
```

#### 剪枝：

回溯法虽然是暴力搜索，但也有时候可以有点剪枝优化一下的。

例如，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了，如图所示：

![77.组合4](imgs/20210130194335207.png)

图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。**所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置**。如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。

注意代码中i，就是for循环里选择的起始位置。

```cpp
for (int i = start; i <= end; i++) {
```

接下来看一下优化过程如下：

1. 已经选择的元素个数：`path.size()`;
2. 所需需要的元素个数为: `k - path.size()`;
3. 列表中剩余元素（`end-i`） >= 所需需要的元素个数（`k - path.size()`）
4. 在集合`n`中至多要从该起始位置 : `i <= end - (k - path.size()) + 1`，开始遍历

为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。

举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。

从2开始搜索都是合理的，可以是组合[2, 3, 4]。

所以优化之后的for循环是：

```cpp
for (int i = start; i <= end - (k - path.size()) + 1; i++) // i为本次搜索的起始位置
```

### 今日总结

新的篇章，新的开始！第一题用卡哥给的回溯模版做出来了，继续加油！